% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_equivalents.R
\name{find_equivalents}
\alias{find_equivalents}
\title{Find equivalent sets of codes at specific dates in a Klass classification}
\usage{
find_equivalents(
  classification,
  dates,
  labellers = list(group_label = function(code, name, validFrom, ...) {
     i =
    which(is.na(validTo))
     paste(code[i], name[i], collapse = ", ")
 }),
  graph = klass_graph(classification)
)
}
\arguments{
\item{classification}{The Klass classification to be used}

\item{dates}{The dates that equivalent sets of codes should be found for.}

\item{labellers}{Named list of functions to be used for building group
labels. The names of the list determine the column names that the
corresponding labels will be placed into.

The default setting adds a column \code{group_label} which includes only the
most recent valid codes in the group and with labels of the following form:

\if{html}{\out{<div class="sourceCode">}}\preformatted{"1508 Ålesund, 1580 Haram"
}\if{html}{\out{</div>}}

Multiple label-columns can be specified by adding more functions to the
list. The following example creates two label columns: one containing the
codes and names, and another with only the codes.

\if{html}{\out{<div class="sourceCode">}}\preformatted{labellers = list(
  group_label = function(code, name, validFrom, ...) \{
    label_codes <- validFrom == max(validFrom)
    paste(code[label_codes], name[label_codes], collapse = ", ")
  \},
  group_code = function(code, validFrom, ...) \{
    label_codes <- validFrom == max(validFrom)
    paste(code[label_codes], collapse = ", ")
  \}
)
}\if{html}{\out{</div>}}

The functions provided in this parameter can accept any of the following
parameters: \code{date} \code{code}, \code{name}, \code{validFrom} and \code{validTo}, representing
the corresponding values of each code in a group. The function must also
provide a \code{...} parameter, unless using all of the above. The functions can
expect that the input variables have the same length of 1 or longer. The
functions should return a character vector of length one or the same length
as the input variables.}

\item{graph}{Optional. Generating the graph using \code{klass_graph} manually
beforehand and providing it in this parameter can save time if running
\code{find_equivalents} multiple times in sequence.}
}
\value{
A data.frame with columns:
\itemize{
\item \code{date} containing the input \code{dates}
\item \code{code} containing the set of equivalent codes in each date
\item \code{name} containing the names of each code
\item \code{validFrom} and \code{validTo} values for each code returned
}

Additionally, the data.frame will contain label columns for each set of
equivalent codes, as generated by the function(s) provided by \code{labellers}.
The names of the label columns are equal to \code{names(labellers)}.
}
\description{
Find equivalent sets of codes at specific dates in a Klass classification
}
\details{
This function provides a solution to the problem of split or
combined codes in Klass classifications. When using \code{\link{update_klass}} to ask
"what is this code in this version of the classification in this other
version of the classification?", the answer is sometimes that the code has
been split into two or more codes (or combined from two or more codes, if
trying to back-date a code), and therefore that the code cannot be updated.

The solution provided by \code{find_equivalents} is answering the question: "in
these versions of the classification, which codes were equivalent to this
code in this other version of the classification?".

Consider the following example of two codes combining into one. Here, \code{"a"}
and \code{"b"} are valid at t1, and are combined into \code{"c"} at t2.

\if{html}{\out{<div class="sourceCode">}}\preformatted{t1     t2
a ──┰─> c
    ┃
b ──┚

}\if{html}{\out{</div>}}

\code{\link{update_klass}} would inform us that \code{"a"} can be updated to
\code{"c"} at t2, unless we specified \code{combine = FALSE}, in which case the
result would be \code{NA}. \code{find_equivalents()} would inform us that the
equivalent of the codes \code{"a"} and \code{"b"} in t1 at t2 is \code{"c"}.

We can also consider a code splitting into two. In this example, \code{"a"} is
valid at t1, and splits into \code{"b"} and \code{"c"} at t2.

\if{html}{\out{<div class="sourceCode">}}\preformatted{t1     t2
a
├─────> b
└─────> c
}\if{html}{\out{</div>}}

\code{\link{update_klass}} is unable to provide an updated code due to the
split, and would return \code{NA}. \code{find_equivalents} would inform us that the
equivalent codes of \code{"a"} at t1 is \code{"b"} and \code{"c"} at t2.

\code{find_equivalents} can handle more than two dates. In the following
example, \code{"a"} splits into \code{"b"} and \code{"c"} at t2, and \code{"b"} and \code{"c"}
combine into \code{"d"} at t3. \code{find_equivalents} can inform us that \code{"a"} is
equivalent to \code{"b"} and \code{"c"} at t2, and \code{"d"} at t3.

\if{html}{\out{<div class="sourceCode">}}\preformatted{t1     t2     t3
a
├─────> b ┐
└─────> c ┴─> d
}\if{html}{\out{</div>}}

\code{find_equivalents} will only search in the time range we specify. As a
consequence, generating sets of equivalent codes over longer time spans
will generally create larger sets than using shorter time spans.

To illustrate this behavior, we can add a new code \code{"e"} to the previous
example, and have \code{"d"} and \code{"e"} combine into \code{"f"} at t4.

\if{html}{\out{<div class="sourceCode">}}\preformatted{t1     t2     t3     t4
a
├─────> b ┐
└─────> c ┴─> d ┐
e ──────────────┴──> f
}\if{html}{\out{</div>}}

Finding the
equivalents of \code{"a"} in t1 at t2 and t3 returns the same sets as
before:
\itemize{
\item t1: \code{"a"}
\item t2: \code{"b"} and \code{"c"}
\item t3: \code{"d"}
}

However, if we also wanted to know the equivalent set for t4, the result
would be:
\itemize{
\item t1: \code{"a"} and \code{"e"}
\item t2: \code{"b"}, \code{"c"} and \code{"e"}
\item t3: \code{"d"} and \code{"e"}
\item t4: \code{"f"}
}
}
