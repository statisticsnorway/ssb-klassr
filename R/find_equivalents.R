#' Find the equivalent sets of a node at various dates
#'
#' @param node The node that we're finding the equivalent sets of
#' @param dates The dates that we want to find the equivalent sets in
#' @param graph The graph that the nodes come from
#'
#' @return A named list of `length(dates)` containing the equivalent nodes for
#'   each date. The names of the returned list are the dates provided in `date`,
#'   coerced to character.
#'
find_equivalent_nodes <- function(node, dates, graph) {
  related_nodes <- igraph::bfs(
    graph = graph,
    root = node,
    mode = "all",
    unreachable = FALSE
  )[["order"]]

  result <- lapply(dates, \(date) {
    result_nodes <- related_nodes[
      date >= related_nodes$validFrom &
        (date < related_nodes$validTo | is.na(related_nodes$validTo))
    ]

    result_nodes[order(result_nodes$code)]
  })

  names(result) <- as.character(dates)

  return(result)
}

#' Find equivalent sets of codes at specific dates in a Klass classification
#'
#' @param classification The Klass classification to be used
#' @param dates The dates that equivalent sets of codes should be found for.
#' @param labellers Named list of functions to be used for building group
#'   labels. The names of the list determine the column names that the
#'   corresponding labels will be placed into.
#'
#'   The default setting adds a column `group_label` which includes only the
#'   most recent valid codes in the group and with labels of the following form:
#'
#'   ```
#'   "1508 Ålesund, 1580 Haram"
#'   ```
#'
#'   Multiple label-columns can be specified by adding more functions to the
#'   list. The following example creates two label columns: one containing the
#'   codes and names, and another with only the codes.
#'
#'   ```
#'   labellers = list(
#'     group_label = function(code, name, validFrom, ...) {
#'       label_codes <- validFrom == max(validFrom)
#'       paste(code[label_codes], name[label_codes], collapse = ", ")
#'     },
#'     group_code = function(code, validFrom, ...) {
#'       label_codes <- validFrom == max(validFrom)
#'       paste(code[label_codes], collapse = ", ")
#'     }
#'   )
#'   ```
#'
#'   The functions provided in this parameter can accept any of the following
#'   parameters: `date` `code`, `name`, `validFrom` and `validTo`, representing
#'   the corresponding values of each code in a group. The function must also
#'   provide a `...` parameter, unless using all of the above. The functions can
#'   expect that the input variables have the same length of 1 or longer. The
#'   functions should return a character vector of length one or the same length
#'   as the input variables.
#'
#' @param graph Optional. Generating the graph using `klass_graph` manually
#'   beforehand and providing it in this parameter can save time if running
#'   `find_equivalents` multiple times in sequence.
#'
#' @return
#'   A data.frame with columns:
#'
#'   - `date` containing the input `dates`
#'   - `code` containing the set of equivalent codes in each date
#'   - `name` containing the names of each code
#'   - `validFrom` and `validTo` values for each code returned
#'
#'   Additionally, the data.frame will contain label columns for each set of
#'   equivalent codes, as generated by the function(s) provided by `labellers`.
#'   The names of the label columns are equal to `names(labellers)`.
#'
#' @details This function provides a solution to the problem of split or
#'   combined codes in Klass classifications. When using \code{\link{update_klass}} to ask
#'   "what is this code in this version of the classification in this other
#'   version of the classification?", the answer is sometimes that the code has
#'   been split into two or more codes (or combined from two or more codes, if
#'   trying to back-date a code), and therefore that the code cannot be updated.
#'
#'   The solution provided by `find_equivalents` is answering the question: "in
#'   these versions of the classification, which codes were equivalent to this
#'   code in this other version of the classification?".
#'
#'   Consider the following example of two codes combining into one. Here, `"a"`
#'   and `"b"` are valid at t1, and are combined into `"c"` at t2.
#'
#'   ```
#'   t1     t2
#'   a ──┰─> c
#'       ┃
#'   b ──┚
#'
#'   ```
#'
#'   \code{\link{update_klass}} would inform us that `"a"` can be updated to
#'   `"c"` at t2, unless we specified `combine = FALSE`, in which case the
#'   result would be `NA`. `find_equivalents()` would inform us that the
#'   equivalent of the codes `"a"` and `"b"` in t1 at t2 is `"c"`.
#'
#'   We can also consider a code splitting into two. In this example, `"a"` is
#'   valid at t1, and splits into `"b"` and `"c"` at t2.
#'
#'   ```
#'   t1     t2
#'   a
#'   ├─────> b
#'   └─────> c
#'   ```
#'
#'   \code{\link{update_klass}} is unable to provide an updated code due to the
#'   split, and would return `NA`. `find_equivalents` would inform us that the
#'   equivalent codes of `"a"` at t1 is `"b"` and `"c"` at t2.
#'
#'
#'   `find_equivalents` can handle more than two dates. In the following
#'   example, `"a"` splits into `"b"` and `"c"` at t2, and `"b"` and `"c"`
#'   combine into `"d"` at t3. `find_equivalents` can inform us that `"a"` is
#'   equivalent to `"b"` and `"c"` at t2, and `"d"` at t3.
#'
#'   ```
#'   t1     t2     t3
#'   a
#'   ├─────> b ┐
#'   └─────> c ┴─> d
#'   ```
#'
#'   `find_equivalents` will only search in the time range we specify. As a
#'   consequence, generating sets of equivalent codes over longer time spans
#'   will generally create larger sets than using shorter time spans.
#'
#'   To illustrate this behavior, we can add a new code `"e"` to the previous
#'   example, and have `"d"` and `"e"` combine into `"f"` at t4.
#'
#'   ```
#'   t1     t2     t3     t4
#'   a
#'   ├─────> b ┐
#'   └─────> c ┴─> d ┐
#'   e ──────────────┴──> f
#'   ```
#'
#'   Finding the
#'   equivalents of `"a"` in t1 at t2 and t3 returns the same sets as
#'   before:
#'
#'   - t1: `"a"`
#'   - t2: `"b"` and `"c"`
#'   - t3: `"d"`
#'
#'   However, if we also wanted to know the equivalent set for t4, the result
#'   would be:
#'
#'   - t1: `"a"` and `"e"`
#'   - t2: `"b"`, `"c"` and `"e"`
#'   - t3: `"d"` and `"e"`
#'   - t4: `"f"`
#'
#' @export
find_equivalents <- function(classification,
                             dates,
                             labellers = list(group_label = \(code, name, validTo, ...) {
                               i <- is.na(validTo)

                               paste(code[i], name[i], collapse = ", ")
                             }),
                             graph = klass_graph(classification)) {
  if (any(is.na(dates))) stop("`dates` cannot be NA.")

  dates <- as.Date(dates)

  if (any(is.na(dates))) {
    stop("Some dates could not be converted to date format.")
  }

  if (!length(dates) > 1) stop("Need to provide at least two dates")

  # Search in codes that were valid before or on max_date and valid to
  # after the min_date (or still valid)
  sgraph <- igraph::subgraph(
    graph,
    igraph::V(graph)$validFrom <= max(dates) &
      (is.na(igraph::V(graph)$validTo) | igraph::V(graph)$validTo >= min(dates))
  )

  result <- data.frame()

  for (i in 1:length(sgraph)) {
    node <- igraph::V(sgraph)[i]

    # build list of equivalent sets of nodes for this node
    equivalent_sets <- find_equivalent_nodes(node, dates, sgraph)

    # instantiate data.frame that will contain information about all equivalent
    # sets for this code
    equivalents_df <- data.frame()

    for (j in seq_along(equivalent_sets)) {
      # build data frame containing information about the codes in this set
      set_df <- as.data.frame(
        igraph::vertex.attributes(sgraph, equivalent_sets[[j]])
      )

      # add date variable specifying at what date this set is valid
      set_df$date <- dates[j]

      # select variables
      set_df <- set_df[c("date", "code", "label", "validFrom", "validTo")]

      # rename `label` to `name` to match output from other klassR functions
      names(set_df)[3] <- "name"

      # add set rows to data.frame containing other sets for this code
      equivalents_df <- rbind(equivalents_df, set_df)
    }

    # construct label across all sets for this according to the labeller
    # function(s) provided by the user
    labels <- lapply(labellers, do.call, args = equivalents_df)

    # apply labels to data.frame containing all equivalent sets for this code
    equivalents_df <- cbind(equivalents_df, labels)

    # add equivalent sets for this code to the final result
    result <- rbind(result, equivalents_df)
  }

  # remove duplicate rows
  result <- unique(result)

  return(result)
}
